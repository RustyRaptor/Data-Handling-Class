class dataUtils: #  PROG To-Do List: - add docstrings to methods,
                    # - replace error string returns with 0 returns and prints

    #  Misc Internal Methods

    #  check if a data set is in order
    def isordered(self, data):
        ordered = 1
        for i in range(1, len(data)):
            if data[i] < data[i - 1]:
                ordered = 0
        return ordered

    #  swaps two arguments given; To-Do: EXPAND/FIT TO SIMPLIFY METHODS
    def listswap(self, data, fir, sec):
        if fir < len(data) and sec < len(data):
            temp = data[fir]
            data[fir] = data[sec]
            data[sec] = temp
        else:
            print("Swap index out of bounds")
        return data

    #gives the number of layers deep the deepest list in a nest list is
    def maxdepth(self, nestedlist):
        if isinstance(nestedlist, list):
            if (len(nestedlist) == 0):
                depth = 1
            else:
                depth = 1 + max([self.maxdepth(l) for l in nestedlist])
        else:
            depth = 0
        return depth

    #  Randomizing Methods

    #  create random test data list of arbitrary size
    def randata(self, length, max, duples=1):
        import random
        if duples == 1:
            randlist = [random.randrange(max) for i in range(length)]
        elif duples == 0:
            if length > max:
                randlist = [0]
                print("ERROR: cannot have unique distribution longer than range;\n" \
                      "Can either decrease length or increase max")
            else:
                randlist = random.sample(range(0,max), length)
        return randlist

    #  shuffles a given data set
    def shuffle(self, data):
        import random
        return random.sample(data, len(data))

    # List Sort Methods

    #  Selection Sorting
    def selsort(self, data, showstep=0):
        for cycle in range(len(data)):
            for i in range(cycle, len(data)):
                if data[cycle] > data[i]:
                    data = self.listswap(data, cycle, i)
                    if showstep == 1:
                        print(data)
        return data

    #  Insertion Sorting
    def insort(self, data, showstep=0):
        insorted = []
        for i in data:
            insorted.append(i)
            pos = len(insorted) - 1
            if showstep == 1:
                print(insorted)
            while insorted[pos - 1] > insorted[pos] and pos > 0:
                insorted = self.listswap(insorted, pos, pos-1)
                pos -= 1
                if showstep == 1:
                    print(insorted)
        return insorted

    #  Bubble Sorting
    def bubblesort(self, data, showstep=0):
        while 1:
            ordrd = self.isordered(data)  #  checks data ordering
            if ordrd == 1:
                return data
            else:
                for i in range(len(data) - 1):
                    if data[i] > data[i + 1]:
                        data = self.listswap(data,i,i+1)
                if showstep == 1:  # Optional printout of sorting steps
                    print(data)

    #  Merge Sorting
    def mergesort(self, data, showstep=0):
        show = showstep
        if len(data) > 1:
            midp = (len(data) // 2)
            left, right = data[:midp], data[midp:]
            left1, right1 = self.mergesort(left, showstep=show), self.mergesort(right, showstep=show)
            if show == 1:
                print(left1, right1)
            # List Merge procedure below, separate for legibility
            result = []
            i = j = 0
            while i < len(left1) and j < len(right1):
                if left1[i] >= right1[j]:
                    result.append(right1[j])
                    j += 1
                else:
                    result.append(left1[i])
                    i += 1
            result += left1[i:]
            result += right1[j:]
            # end of joining
        else:
            result = data
        return result

    # List search methods

    # binary search, DATA MUST BE ORDERED!
    def binsearch(self, data, target):
        pos = len(data) + 1
        if self.isordered(data) == 1:  # check data ordering
            head, tail = 0, len(data) - 1
            while pos == len(data) + 1:  # searchbound adjustment logic
                mid = (head + tail) // 2
                if data[mid] == target:
                    pos = mid
                elif (tail <= head) and (pos == len(data) + 1):
                    pos = "Not in list"
                elif data[mid] > target:
                    tail = mid - 1
                else:
                    head = mid + 1
        else:
            pos = "ERROR: List not in order"
        return "\nIndex of %d: %s" % (target, str(pos))  # Note that the position is returned as a string
                                                        #To-Do: Edit output types/feedback

d = dataUtils()
dataset = d.randata(20, 20, duples=0)
#print(dataset, d.binsearch(d.insort(dataset), 11), "\n---------")
#print(d.maxdepth([1,2]))
print(d.mergesort(dataset, showstep = 1))
